/**
 * ```js
 * Plot.groupZ({x: "proportion"}, {fill: "species"})
 * ```
 *
 * Groups on the first channel of *z*, *fill*, or *stroke*, if any. If none of
 * *z*, *fill*, or *stroke* are channels, then all data (within each facet) is
 * placed into a single group.
 *
 * @link https://github.com/observablehq/plot/blob/main/README.md#group
 */
export function groupZ(outputs: any, options: any): {
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    x: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    x1: any;
    x2: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y1: any;
    y2: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y: any;
    x: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y1: any;
    y2: any;
    x: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y: any;
    x1: any;
    x2: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y1: any;
    y2: any;
    x1: any;
    x2: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
};
/**
 * ```js
 * Plot.groupX({y: "sum"}, {x: "species", y: "body_mass_g"})
 * ```
 *
 * Groups on *x* and the first channel of *z*, *fill*, or *stroke*, if any.
 *
 * @link https://github.com/observablehq/plot/blob/main/README.md#group
 */
export function groupX(outputs?: {
    y: string;
}, options?: {}): {
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    x: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    x1: any;
    x2: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y1: any;
    y2: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y: any;
    x: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y1: any;
    y2: any;
    x: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y: any;
    x1: any;
    x2: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y1: any;
    y2: any;
    x1: any;
    x2: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
};
/**
 * ```js
 * Plot.groupY({x: "sum"}, {y: "species", x: "body_mass_g"})
 * ```
 *
 * Groups on *y* and the first channel of *z*, *fill*, or *stroke*, if any.
 *
 * @link https://github.com/observablehq/plot/blob/main/README.md#group
 */
export function groupY(outputs?: {
    x: string;
}, options?: {}): {
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    x: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    x1: any;
    x2: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y1: any;
    y2: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y: any;
    x: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y1: any;
    y2: any;
    x: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y: any;
    x1: any;
    x2: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y1: any;
    y2: any;
    x1: any;
    x2: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
};
/**
 * ```js
 * Plot.group({fill: "count"}, {x: "island", y: "species"})
 * ```
 *
 * Groups on *x*, *y*, and the first channel of *z*, *fill*, or *stroke*, if
 * any.
 *
 * @link https://github.com/observablehq/plot/blob/main/README.md#group
 */
export function group(outputs?: {
    fill: string;
}, options?: {}): {
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    x: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    x1: any;
    x2: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y1: any;
    y2: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y: any;
    x: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y1: any;
    y2: any;
    x: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y: any;
    x1: any;
    x2: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
} | {
    y1: any;
    y2: any;
    x1: any;
    x2: any;
    transform: any;
    sort?: any;
    stroke?: any;
    fill?: any;
    z?: any;
};
export function hasOutput(outputs: any, ...names: any[]): boolean;
export function maybeOutputs(outputs: any, inputs: any): ({
    name: any;
    output: ((v: any) => any) | {
        transform: () => any;
        label: any;
    };
    initialize(data: any): void;
    scope(scope: any, I: any): void;
    reduce(I: any, extent: any): void;
} | {
    name: string;
    initialize(): void;
    scope(): void;
    reduce(): void;
})[];
export function maybeOutput(name: any, reduce: any, inputs: any): {
    name: any;
    output: ((v: any) => any) | {
        transform: () => any;
        label: any;
    };
    initialize(data: any): void;
    scope(scope: any, I: any): void;
    reduce(I: any, extent: any): void;
};
export function maybeEvaluator(name: any, reduce: any, inputs: any): {
    label: any;
    initialize(data: any): void;
    scope(scope: any, I: any): void;
    reduce(I: any, extent: any): any;
};
export function maybeGroup(I: any, X: any): any[][];
export function maybeReduce(reduce: any, value: any): any;
export function maybeSubgroup(outputs: any, inputs: any): any;
export function maybeSort(facets: any, sort: any, reverse: any): void;
export namespace reduceIdentity {
    function reduce(I: any, X: any): any[];
    function reduce(I: any, X: any): any[];
}
export namespace reduceFirst {
    function reduce(I: any, X: any): any;
    function reduce(I: any, X: any): any;
}
export namespace reduceCount {
    const label: string;
    function reduce(I: any): any;
    function reduce(I: any): any;
}
