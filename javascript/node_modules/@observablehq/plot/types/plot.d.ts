/**
 * Renders a new plot given the specified *options* and returns the
 * corresponding SVG or HTML figure element. All *options* are optional.
 *
 * ### Mark options
 *
 * The **marks** option specifies an array of
 * [marks](https://github.com/observablehq/plot/blob/main/README.md#marks) to
 * render. Each mark has its own data and options; see the respective mark type
 * (*e.g.*, [bar](https://github.com/observablehq/plot/blob/main/README.md#bar)
 * or [dot](https://github.com/observablehq/plot/blob/main/README.md#dot)) for
 * which mark options are supported. Each mark may be a nested array of marks,
 * allowing composition. Marks may also be a function which returns an SVG
 * element, if you wish to insert some arbitrary content into your plot. And
 * marks may be null or undefined, which produce no output; this is useful for
 * showing marks conditionally (*e.g.*, when a box is checked). Marks are drawn
 * in *z* order, last on top. For example, here a single rule at *y* = 0 is
 * drawn on top of blue bars for the [*alphabet*
 * dataset](https://github.com/observablehq/plot/blob/main/test/data/alphabet.csv).
 *
 * ```js
 * Plot.plot({
 *   marks: [
 *     Plot.barY(alphabet, {x: "letter", y: "frequency", fill: "steelblue"}),
 *     Plot.ruleY([0])
 *   ]
 * })
 * ```
 *
 * ### Layout options
 *
 * These options determine the overall layout of the plot; all are specified as
 * numbers in pixels:
 *
 * * **marginTop** - the top margin
 * * **marginRight** - the right margin
 * * **marginBottom** - the bottom margin
 * * **marginLeft** - the left margin
 * * **margin** - shorthand for the four margins
 * * **width** - the outer width of the plot (including margins)
 * * **height** - the outer height of the plot (including margins)
 *
 * The default **width** is 640. On Observable, the width can be set to the
 * [standard
 * width](https://github.com/observablehq/stdlib/blob/main/README.md#width) to
 * make responsive plots. The default **height** is chosen automatically based
 * on the plot’s associated scales; for example, if *y* is linear and there is
 * no *fy* scale, it might be 396.
 *
 * The default margins depend on the plot’s axes: for example, **marginTop** and
 * **marginBottom** are at least 30 if there is a corresponding top or bottom
 * *x* axis, and **marginLeft** and **marginRight** are at least 40 if there is
 * a corresponding left or right *y* axis. For simplicity’s sake and for
 * consistent layout across plots, margins are not automatically sized to make
 * room for tick labels; instead, shorten your tick labels or increase the
 * margins as needed. (In the future, margins may be specified indirectly via a
 * scale property to make it easier to reorient axes without adjusting margins;
 * see [#210](https://github.com/observablehq/plot/issues/210).)
 *
 * The **style** option allows custom styles to override Plot’s defaults. It may
 * be specified either as a string of inline styles (*e.g.*, `"color: red;"`, in
 * the same fashion as assigning
 * [*element*.style](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style))
 * or an object of properties (*e.g.*, `{color: "red"}`, in the same fashion as
 * assigning [*element*.style
 * properties](https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration)).
 * Note that unitless numbers ([quirky
 * lengths](https://www.w3.org/TR/css-values-4/#deprecated-quirky-length)) such
 * as `{padding: 20}` may not supported by some browsers; you should instead
 * specify a string with units such as `{padding: "20px"}`. By default, the
 * returned plot has a white background, a max-width of 100%, and the system-ui
 * font. Plot’s marks and axes default to
 * [currentColor](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#currentcolor_keyword),
 * meaning that they will inherit the surrounding content’s color. For example,
 * a dark theme:
 *
 * ```js
 * Plot.plot({
 *   marks: …,
 *   style: {
 *     background: "black",
 *     color: "white"
 *   }
 * })
 * ```
 *
 * If a **caption** is specified, Plot.plot wraps the generated SVG element in
 * an HTML figure element with a figcaption, returning the figure. To specify an
 * HTML caption, consider using the [`html` tagged template
 * literal](http://github.com/observablehq/htl); otherwise, the specified string
 * represents text that will be escaped as needed.
 *
 * ```js
 * Plot.plot({
 *   marks: …,
 *   caption: html`Figure 1. This chart has a <i>fancy</i> caption.`
 * })
 * ```
 *
 * The generated SVG element has a random class name which applies a default
 * stylesheet. Use the top-level **className** option to specify that class
 * name.
 *
 * The **document** option specifies the
 * [document](https://developer.mozilla.org/en-US/docs/Web/API/Document) used to
 * create plot elements. It defaults to window.document, but can be changed to
 * another document, say when using a virtual DOM library for server-side
 * rendering in Node.
 *
 * ### Scale options
 *
 * Plot passes data through
 * [scales](https://observablehq.com/@observablehq/plot-scales) as needed before
 * rendering marks. A scale maps abstract values such as time or temperature to
 * visual values such as position or color. Within a given plot, marks share
 * scales. For example, if a plot has two Plot.line marks, both share the same
 * *x* and *y* scales for a consistent representation of data. (Plot does not
 * currently support dual-axis charts, which are [not
 * advised](https://blog.datawrapper.de/dualaxis/).)
 *
 * ```js
 * Plot.plot({
 *   marks: [
 *     Plot.line(aapl, {x: "Date", y: "Close"}),
 *     Plot.line(goog, {x: "Date", y: "Close"})
 *   ]
 * })
 * ```
 *
 * Each scale’s options are specified as a nested options object with the
 * corresponding scale name within the top-level plot *options*:
 *
 * * **x** - horizontal position
 * * **y** - vertical position
 * * **r** - radius (size)
 * * **color** - fill or stroke
 * * **opacity** - fill or stroke opacity
 * * **length** - linear length (for
 *   [vectors](https://github.com/observablehq/plot/blob/main/README.md#vector))
 * * **symbol** - categorical symbol (for
 *   [dots](https://github.com/observablehq/plot/blob/main/README.md#dot))
 *
 * For example, to set the domain for the *x* and *y* scales:
 *
 * ```js
 * Plot.plot({
 *   x: {
 *     domain: [new Date("1880-01-01"), new Date("2016-11-01")]
 *   },
 *   y: {
 *     domain: [-0.78, 1.35]
 *   }
 * })
 * ```
 *
 * Plot supports many scale types. Some scale types are for quantitative data:
 * values that can be added or subtracted, such as temperature or time. Other
 * scale types are for ordinal or categorical data: unquantifiable values that
 * can only be ordered, such as t-shirt sizes, or values with no inherent order
 * that can only be tested for equality, such as types of fruit. Some scale
 * types are further intended for specific visual encodings: for example, as
 * [position](https://github.com/observablehq/plot/blob/main/README.md#position-options)
 * or
 * [color](https://github.com/observablehq/plot/blob/main/README.md#color-options).
 *
 * You can set the scale type explicitly via the *scale*.**type** option, though
 * typically the scale type is inferred automatically. Some marks mandate a
 * particular scale type: for example,
 * [Plot.barY](https://github.com/observablehq/plot/blob/main/README.md#plotbarydata-options)
 * requires that the *x* scale is a *band* scale. Some scales have a default
 * type: for example, the *radius* scale defaults to *sqrt* and the *opacity*
 * scale defaults to *linear*. Most often, the scale type is inferred from
 * associated data, pulled either from the domain (if specified) or from
 * associated channels. A *color* scale defaults to *identity* if no range or
 * scheme is specified and all associated defined values are valid CSS color
 * strings. Otherwise, strings and booleans imply an ordinal scale; dates imply
 * a UTC scale; and anything else is linear. Unless they represent text, we
 * recommend explicitly converting strings to more specific types when loading
 * data (*e.g.*, with d3.autoType or Observable’s FileAttachment). For
 * simplicity’s sake, Plot assumes that data is consistently typed; type
 * inference is based solely on the first non-null, non-undefined value.
 *
 * For quantitative data (*i.e.* numbers), a mathematical transform may be
 * applied to the data by changing the scale type:
 *
 * * *linear* (default) - linear transform (translate and scale)
 * * *pow* - power (exponential) transform
 * * *sqrt* - square-root transform (*pow* transform with exponent = 0.5)
 * * *log* - logarithmic transform
 * * *symlog* - bi-symmetric logarithmic transform per [Webber *et
 *   al.*](https://www.researchgate.net/publication/233967063_A_bi-symmetric_log_transformation_for_wide-range_data)
 *
 * The appropriate transform depends on the data’s distribution and what you
 * wish to know. A *sqrt* transform exaggerates differences between small values
 * at the expense of large values; it is a special case of the *pow* transform
 * which has a configurable *scale*.**exponent** (0.5 for *sqrt*). A *log*
 * transform is suitable for comparing orders of magnitude and can only be used
 * when the domain does not include zero. The base defaults to 10 and can be
 * specified with the *scale*.**base** option; note that this only affects the
 * axis ticks and not the scale’s behavior. A *symlog* transform is more
 * elaborate, but works well with wide-range values that include zero; it can be
 * configured with the *scale*.**constant** option (default 1).
 *
 * For temporal data (*i.e.* dates), two variants of a *linear* scale are also
 * supported:
 *
 * * *utc* (default, recommended) - UTC time
 * * *time* - local time
 *
 * UTC is recommended over local time as charts in UTC time are guaranteed to
 * appear consistently to all viewers whereas charts in local time will depend
 * on the viewer’s time zone. Due to limitations in JavaScript’s Date class,
 * Plot does not yet support an explicit time zone other than UTC.
 *
 * For ordinal data (*e.g.*, strings), use the *ordinal* scale type or the
 * *point* or *band* [position scale
 * types](https://github.com/observablehq/plot/blob/main/README.md#position-options).
 * The *categorical* scale type is also supported; it is equivalent to *ordinal*
 * except as a [color
 * scale](https://github.com/observablehq/plot/blob/main/README.md#color-options),
 * where it provides a different default color scheme. (Since position is
 * inherently ordinal or even quantitative, categorical data must be assigned an
 * effective order when represented as position, and hence *categorical* and
 * *ordinal* may be considered synonymous in context.)
 *
 * You can opt-out of a scale using the *identity* scale type. This is useful if
 * you wish to specify literal colors or pixel positions within a mark channel
 * rather than relying on the scale to convert abstract values into visual
 * values. For position scales (*x* and *y*), an *identity* scale is still
 * quantitative and may produce an axis, yet unlike a *linear* scale the domain
 * and range are fixed based on the plot layout.
 *
 * Quantitative scales, as well as identity position scales, coerce channel
 * values to numbers; both null and undefined are coerced to NaN. Similarly,
 * time scales coerce channel values to dates; numbers are assumed to be
 * milliseconds since UNIX epoch, while strings are assumed to be in [ISO 8601
 * format](https://github.com/mbostock/isoformat/blob/main/README.md#parsedate-fallback).
 *
 * A scale’s domain (the extent of its inputs, abstract values) and range (the
 * extent of its outputs, visual values) are typically inferred automatically.
 * You can set them explicitly using these options:
 *
 * * *scale*.**domain** - typically [*min*, *max*], or an array of ordinal or
 *   categorical values
 * * *scale*.**range** - typically [*min*, *max*], or an array of ordinal or
 *   categorical values
 * * *scale*.**unknown** - the desired output value (defaults to undefined) for
 *   invalid input values
 * * *scale*.**reverse** - reverses the domain (or in somes cases, the range),
 *   say to flip the chart along *x* or *y*
 * * *scale*.**interval** - an interval or time interval (for interval data; see
 *   below)
 *
 * For most quantitative scales, the default domain is the [*min*, *max*] of all
 * values associated with the scale. For the *radius* and *opacity* scales, the
 * default domain is [0, *max*] to ensure a meaningful value encoding. For
 * ordinal scales, the default domain is the set of all distinct values
 * associated with the scale in natural ascending order; for a different order,
 * set the domain explicitly or add a [sort
 * option](https://github.com/observablehq/plot/blob/main/README.md#sort-options)
 * to an associated mark. For threshold scales, the default domain is [0] to
 * separate negative and non-negative values. For quantile scales, the default
 * domain is the set of all defined values associated with the scale. If a scale
 * is reversed, it is equivalent to setting the domain as [*max*, *min*] instead
 * of [*min*, *max*].
 *
 * The default range depends on the scale: for [position
 * scales](https://github.com/observablehq/plot/blob/main/README.md#position-options)
 * (*x*, *y*, *fx*, and *fy*), the default range depends on the plot’s [size and
 * margins](https://github.com/observablehq/plot/blob/main/README.md#layout-options).
 * For [color
 * scales](https://github.com/observablehq/plot/blob/main/README.md#color-options),
 * there are default color schemes for quantitative, ordinal, and categorical
 * data. For opacity, the default range is [0, 1]. And for radius, the default
 * range is designed to produce dots of “reasonable” size assuming a *sqrt*
 * scale type for accurate area representation: zero maps to zero, the first
 * quartile maps to a radius of three pixels, and other values are extrapolated.
 * This convention for radius ensures that if the scale’s data values are all
 * equal, dots have the default constant radius of three pixels, while if the
 * data varies, dots will tend to be larger.
 *
 * The behavior of the *scale*.**unknown** option depends on the scale type. For
 * quantitative and temporal scales, the unknown value is used whenever the
 * input value is undefined, null, or NaN. For ordinal or categorical scales,
 * the unknown value is returned for any input value outside the domain. For
 * band or point scales, the unknown option has no effect; it is effectively
 * always equal to undefined. If the unknown option is set to undefined (the
 * default), or null or NaN, then the affected input values will be considered
 * undefined and filtered from the output.
 *
 * For data at regular intervals, such as integer values or daily samples, the
 * *scale*.**interval** option can be used to enforce uniformity. The specified
 * *interval*—such as d3.utcMonth—must expose an *interval*.floor(*value*),
 * *interval*.offset(*value*), and *interval*.range(*start*, *stop*) functions.
 * The option can also be specified as a number, in which case it will be
 * promoted to a numeric interval with the given step. This option sets the
 * default *scale*.transform to the given interval’s *interval*.floor function.
 * In addition, the default *scale*.domain is an array of uniformly-spaced
 * values spanning the extent of the values associated with the scale.
 *
 * Quantitative scales can be further customized with additional options:
 *
 * * *scale*.**clamp** - if true, clamp input values to the scale’s domain
 * * *scale*.**nice** - if true (or a tick count), extend the domain to nice
 *   round values
 * * *scale*.**zero** - if true, extend the domain to include zero if needed
 * * *scale*.**percent** - if true, transform proportions in [0, 1] to
 *   percentages in [0, 100]
 *
 * Clamping is typically used in conjunction with setting an explicit domain
 * since if the domain is inferred, no values will be outside the domain.
 * Clamping is useful for focusing on a subset of the data while ensuring that
 * extreme values remain visible, but use caution: clamped values may need an
 * annotation to avoid misinterpretation. Top-level **clamp**, **nice**, and
 * **zero** options are supported as shorthand for setting the respective option
 * on all scales.
 *
 * The *scale*.**transform** option allows you to apply a function to all values
 * before they are passed through the scale. This is convenient for transforming
 * a scale’s data, say to convert to thousands or between temperature units.
 *
 * ```js
 * Plot.plot({
 *   y: {
 *     label: "↑ Temperature (°F)",
 *     transform: f => f * 9 / 5 + 32 // convert Celsius to Fahrenheit
 *   },
 *   marks: …
 * })
 * ```
 *
 * #### *plot*.scale(*scaleName*)
 *
 * Scale definitions can be exposed through the *plot*.**scale**(*scaleName*)
 * function of a returned plot. The *scaleName* must be one of the known scale
 * names: `"x"`, `"y"`, `"fx"`, `"fy"`, `"r"`, `"color"`, `"opacity"`,
 * `"symbol"`, or `"length"`. If the associated *plot* has no scale with the
 * given *scaleName*, returns undefined.
 *
 * ```js
 * const plot = Plot.plot(…); // render a plot
 * const color = plot.scale("color"); // retrieve the color scale object
 * console.log(color.range); // inspect the color scale’s range, ["red", "blue"]
 * ```
 */
export function plot(options?: {}): any;
/**
 * A convenience method for composing a mark from a series of other marks.
 * Returns an array of marks that implements the *mark*.plot function. See the
 * [box mark
 * implementation](https://github.com/observablehq/plot/blob/main/src/marks/box.js)
 * for an example.
 */
export function marks(...marks: any[]): any[];
export class Mark {
    constructor(data: any, channels: {} | undefined, options: {} | undefined, defaults: any);
    data: any;
    sort: any;
    initializer: any;
    transform: any;
    facet: string | null;
    channels: {
        [k: string]: any;
    };
    dx: number;
    dy: number;
    clip: string | boolean;
    initialize(facets: any, facetChannels: any): {
        data: any;
        facets: any;
        channels: {
            [k: string]: {
                scale: any;
                type: any;
                value: any;
                label: any;
                filter: any;
                hint: any;
            };
        };
    };
    filter(index: any, channels: any, values: any): any;
    plot({ marks, ...options }?: {
        marks?: any[] | undefined;
    }): any;
}
