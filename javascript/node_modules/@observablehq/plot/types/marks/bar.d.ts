/**
 * ```js
 * Plot.barX(alphabet, {y: "letter", x: "frequency"})
 * ```
 *
 * Returns a new horizontal bar↔︎ with the given *data* and *options*. The
 * following channels are required:
 *
 * * **x1** - the starting horizontal position; bound to the *x* scale
 * * **x2** - the ending horizontal position; bound to the *x* scale
 *
 * If neither the **x1** nor **x2** option is specified, the **x** option may be
 * specified as shorthand to apply an implicit [stackX
 * transform](https://github.com/observablehq/plot/blob/main/README.md#plotstackxstack-options);
 * this is the typical configuration for a horizontal bar chart with bars
 * aligned at *x* = 0. If the **x** option is not specified, it defaults to the
 * identity function. If *options* is undefined, then it defaults to **x2** as
 * the identity function and **y** as the index of data; this allows an array of
 * numbers to be passed to Plot.barX to make a quick sequential bar chart.
 *
 * If an **interval** is specified, such as d3.utcDay, **x1** and **x2** can be
 * derived from **x**: *interval*.floor(*x*) is invoked for each *x* to produce
 * *x1*, and *interval*.offset(*x1*) is invoked for each *x1* to produce *x2*.
 * If the interval is specified as a number *n*, *x1* and *x2* are taken as the
 * two consecutive multiples of *n* that bracket *x*.
 *
 * In addition to the [standard bar
 * channels](https://github.com/observablehq/plot/blob/main/README.md#bar), the
 * following optional channels are supported:
 *
 * * **y** - the vertical position; bound to the *y* scale, which must be *band*
 *
 * If the **y** channel is not specified, the bar will span the full vertical
 * extent of the plot (or facet).
 */
export function barX(data: any, options?: {
    y: (d: any, i: any) => any;
    x2: {
        transform: (d: any) => any;
    };
}): BarX;
/**
 * ```js
 * Plot.barY(alphabet, {x: "letter", y: "frequency"})
 * ```
 *
 * Returns a new vertical bar↕︎ with the given *data* and *options*. The
 * following channels are required:
 *
 * * **y1** - the starting vertical position; bound to the *y* scale
 * * **y2** - the ending vertical position; bound to the *y* scale
 *
 * If neither the **y1** nor **y2** option is specified, the **y** option may be
 * specified as shorthand to apply an implicit [stackY
 * transform](https://github.com/observablehq/plot/blob/main/README.md#plotstackystack-options);
 * this is the typical configuration for a vertical bar chart with bars aligned
 * at *y* = 0. If the **y** option is not specified, it defaults to the identity
 * function. If *options* is undefined, then it defaults to **y2** as the
 * identity function and **x** as the index of data; this allows an array of
 * numbers to be passed to Plot.barY to make a quick sequential bar chart.
 *
 * If an **interval** is specified, such as d3.utcDay, **y1** and **y2** can be
 * derived from **y**: *interval*.floor(*y*) is invoked for each *y* to produce
 * *y1*, and *interval*.offset(*y1*) is invoked for each *y1* to produce *y2*.
 * If the interval is specified as a number *n*, *y1* and *y2* are taken as the
 * two consecutive multiples of *n* that bracket *y*.
 *
 * In addition to the [standard bar
 * channels](https://github.com/observablehq/plot/blob/main/README.md#bar), the
 * following optional channels are supported:
 *
 * * **x** - the horizontal position; bound to the *x* scale, which must be
 *   *band*
 *
 * If the **x** channel is not specified, the bar will span the full horizontal
 * extent of the plot (or facet).
 */
export function barY(data: any, options?: {
    x: (d: any, i: any) => any;
    y2: {
        transform: (d: any) => any;
    };
}): BarY;
export class AbstractBar extends Mark {
    constructor(data: any, channels: any, options: {} | undefined, defaults: any);
    insetTop: any;
    insetRight: any;
    insetBottom: any;
    insetLeft: any;
    rx: any;
    ry: any;
    render(index: any, scales: any, channels: any, dimensions: any, context: any): any;
    _x(scales: any, { x }: {
        x: any;
    }, { marginLeft }: {
        marginLeft: any;
    }): any;
    _y(scales: any, { y }: {
        y: any;
    }, { marginTop }: {
        marginTop: any;
    }): any;
    _width({ x }: {
        x: any;
    }, { x }: {
        x: any;
    }, { marginRight, marginLeft, width }: {
        marginRight: any;
        marginLeft: any;
        width: any;
    }): number;
    _height({ y }: {
        y: any;
    }, { y }: {
        y: any;
    }, { marginTop, marginBottom, height }: {
        marginTop: any;
        marginBottom: any;
        height: any;
    }): number;
}
export class BarX extends AbstractBar {
    constructor(data: any, options?: {});
    _transform(selection: any, mark: any, { x }: {
        x: any;
    }): void;
    _x({ x }: {
        x: any;
    }, { x1, x2 }: {
        x1: any;
        x2: any;
    }, { marginLeft }: {
        marginLeft: any;
    }): any;
    _width({ x }: {
        x: any;
    }, { x1, x2 }: {
        x1: any;
        x2: any;
    }, { marginRight, marginLeft, width }: {
        marginRight: any;
        marginLeft: any;
        width: any;
    }): number | ((i: any) => number);
}
export class BarY extends AbstractBar {
    constructor(data: any, options?: {});
    _transform(selection: any, mark: any, { y }: {
        y: any;
    }): void;
    _y({ y }: {
        y: any;
    }, { y1, y2 }: {
        y1: any;
        y2: any;
    }, { marginTop }: {
        marginTop: any;
    }): any;
    _height({ y }: {
        y: any;
    }, { y1, y2 }: {
        y1: any;
        y2: any;
    }, { marginTop, marginBottom, height }: {
        marginTop: any;
        marginBottom: any;
        height: any;
    }): number | ((i: any) => number);
}
import { Mark } from "../plot.js";
